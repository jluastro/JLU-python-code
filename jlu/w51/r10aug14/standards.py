from pyraf import iraf as ir
import pyfits
import math
import asciidata
import numpy as np
import pylab as py
from scipy import optimize
import glob
from jlu.nirc2.photometry import run_phot
import pdb
import find_apertures as findap

dataDir = '/u/jlu/data/w51/10aug14/clean/'
stars = ['FS140', 'FS144', 'FS148']
filters = ['H', 'Kp', 'K']


def extract_all_standards():
    for star in stars:
        for filt in filters:
            if star == 'FS144' and filt == 'K':
                continue

            starName = star.lower()
            filter = filt.lower()

            print 'Extracting %s_%s' % (starName, filter)
            extract_standard(starName, filter)


def extract_standard(name, filter):
    images = glob.glob(dataDir + name + '_' + filter + '/c????.fits')
    imageRoots = [ii.replace('.fits', '') for ii in images]

    aperture = findap.standard_aperture[filter]
    skyannul = findap.sky_annulus_start[filter]
    skywidth = findap.sky_annulus_width[filter]

    for image in imageRoots:
        (r, f, m, me) = run_phot(image, silent=False,
                                 apertures=[aperture],
                                 sky_annulus=skyannul,
                                 sky_dannulus=skywidth)

    
def make_catalog():
    standardsFile = '/u/jlu/work/observe/ukirt_faint_standards_izyjhklm.dat'
    f_ukirt_fs = asciidata.open(standardsFile)

    fsname = f_ukirt_fs[0]._data
    RA = f_ukirt_fs[2]._data
    Dec = f_ukirt_fs[3]._data

    starCnt = len(fsname)

    hmag = np.zeros(starCnt, dtype=float)
    herr = np.zeros(starCnt, dtype=float)
    kmag = np.zeros(starCnt, dtype=float)
    kerr = np.zeros(starCnt, dtype=float)
    lpmag = np.zeros(starCnt, dtype=float)
    lperr = np.zeros(starCnt, dtype=float)

    for ii in range(starCnt):
        try:
            if ('&' in f_ukirt_fs[16][ii]):
                hmag[ii] = np.nan
                herr[ii] = np.nan
            else:
                hmag[ii] = float(f_ukirt_fs[16][ii].strip())
                herr[ii] = float(f_ukirt_fs[17][ii].strip(' ()'))

            if ('&' in f_ukirt_fs[19][ii]):
                kmag[ii] = np.nan
                kerr[ii] = np.nan
            else:
                kmag[ii] = float(f_ukirt_fs[19][ii])
                kerr[ii] = float(f_ukirt_fs[20][ii].strip(' ()'))
                
            if ('&' in f_ukirt_fs[22][ii]):
                lpmag[ii] = np.nan
                lperr[ii] = np.nan
            else:
                lpmag[ii] = float(f_ukirt_fs[22][ii])
                lperr[ii] = float(f_ukirt_fs[23][ii].strip(' ()'))
        except ValueError:
            print 'ii = ', ii, fsname[ii], f_ukirt_fs[1][ii]
            print '.%s.' % (f_ukirt_fs[23][ii])
            raise
            
    kpmag = kmag + 0.22 * (hmag - kmag)
    kperr = np.sqrt(kerr**2 + 0.22**2 * (herr**2 + kerr**2))

    _out = open('photcal_ukirt_faint.dat', 'w')
    _out.write('%-9s  %9s %9s  %9s %9s  %9s %9s\n' %
               ('#ID', 'H', 'err(H)', 'Kp', 'err(Kp)', 'K', 'err(K)'))

    for ii in range(len(fsname)):
        if ((not '&' in fsname[ii]) 
            and kpmag[ii] > 0
            and hmag[ii] > 0
            and kmag[ii] > 0):

            _out.write('FS%-6s' % (fsname[ii]))
            _out.write('  %9.3f %9.3f' % (hmag[ii], herr[ii]))
            _out.write('  %9.3f %9.3f' % (kpmag[ii], kperr[ii]))
            _out.write('  %9.3f %9.3f' % (kmag[ii], kerr[ii]))
            _out.write('\n')

    _out.close()

    _fout = open('fphotcal_ukirt_faint.dat', 'w')
    _fout.write('# Declare the UKIRT HKpK standards catalog variables\n')
    _fout.write('\ncatalog\n\n')
    _fout.write('H         2     # H magnitude\n')
    _fout.write('err(H)    3     # err H\n')
    _fout.write('Kp        4     # Kp magnitude\n')
    _fout.write('err(Kp)   5     # err (Kp)\n')
    _fout.write('K         6     # K magnitude\n')
    _fout.write('err(K)    7     # err (K)\n')
    _fout.close()

    _tout = open('tphotcal_ukirt_faint.dat', 'w')
    _tout.write('\ntransformation\n\n')
    _tout.write('fit   h1=0.0, h2=0.05, h3=0.000, h4=0.000\n')
    _tout.write('HFIT  : mH = H + h1 + h2 * XH + h3 * (H - Kp) + h4 * XH * (H - Kp)\n\n')
    _tout.write('fit   kp1=0.0, kp2=0.05, kp3=0.000, kp4=0.000\n')
    _tout.write('KpFIT : mKp = Kp + kp1 + kp2 * XKp + kp3 * (H - Kp) + kp4 * XKp * (H - Kp)\n\n')
    _tout.write('fit   k1=0.0, k2=0.05, k3=0.000, k4=0.000\n')
    _tout.write('KFIT : mK = K + k1 + k2 * XK + k3 * (H - K) + k4 * XK * (H - K)\n')
    _tout.close()

                
def organizeFiles():
    # Create files that are usually generated by mkimset.
    # We have more information about how to properly group our
    # files together.
    imsetsFilename = 'standards.imageSets'
    obsparFilename = 'standards.obsParams'
    shiftsFilename = 'standards.shifts'
    iMagniFilename = 'standards.instMag' 

    imsets = open(imsetsFilename, 'w')
    obspar = open(obsparFilename, 'w')
    shifts = open(shiftsFilename, 'w')

    for star in stars:
        roots = []

        for filter in filters:
            if star == 'FS144' and filter == 'K':
                continue

            dir = star.lower() + '_' + filter.lower()
                
            images = glob.glob(dataDir + dir + '/c????.fits')
            imageRoots = []
            for ii in images:
                fileRoot = ii.split('/')[-1]
                imageRoots.append(fileRoot.replace('.fits', ''))

            roots.append(imageRoots)
            print star, filter, len(imageRoots)
            
        longCount = np.array([len(r) for r in roots]).max()
        print 'Long Count for %s = %d' % (star, longCount)

        for ii in range(longCount):
            imsets.write('%5s :  ' % star)

            for ff in range(len(roots)):
                if ii < len(roots[ff]):
                    # Write obsParams 
                    ir.txdump(roots[ff][ii] + '.phot.mag', 
                              'IMAGE,IFILTER,ITIME,XAIRMASS,OTIME', 
                              'yes', Stdout=obspar)

                    # Write shifts
                    posInfo = ir.txdump(roots[ff][ii] + '.phot.mag', 
                                        'IMAGE,XCENTER,YCENTER', 
                                        'yes', Stdout=1)
                    posFields = posInfo[0].split()
                    shiftX = -1.0 * float(posFields[1])
                    shiftY = -1.0 * float(posFields[2])
                    shifts.write('%-10s  %7.2f  %7.2f\n' % 
                                 (posFields[0], shiftX, shiftY))
                                                          
                    
                    # Write imageSet
                    imsets.write('%-10s  ' % (roots[ff][ii] + '.fits'))
                else:
                    imsets.write('%-10s  ' % ('INDEF'))

            imsets.write('\n')

    imsets.close()
    obspar.close()
    shifts.close()

    # Now run mknobsfile
    ir.delete(iMagniFilename)
    ir.digiphot()
    ir.photcal()
    ir.unlearn('mknobsfile')
    ir.mknobsfile.obsparams = obsparFilename
    ir.mknobsfile.shifts = shiftsFilename
    ir.mknobsfile('*.phot.mag', ','.join(filters), imsetsFilename, 
                  iMagniFilename, verbose='no', wrap='no')
    
    

    # Run mkconfig
    ir.delete('standards.config')
    ir.unlearn('mkconfig')
    ir.mkconfig('standards.config', 'fphotcal_ukirt_faint.dat', 
                'fstandards.instMag.dat', 'tphotcal_ukirt_faint.dat', 
                check='no', edit='no')

    
def run_fitparams(weight=True):
    if weight: 
        weighting = 'photometric'
    else:
        weighting = 'uniform'

    ir.delete('standards.transParams')
    ir.digiphot()
    ir.photcal()
    ir.unlearn('fitparams')
    ir.fitparams('standards.instMag', 'photcal_ukirt_faint.dat',
                 'standards.config', 'standards.transParams',
                 weighting=weighting)

def plot_fitparams(file, filter, suffix):
    transTable = asciidata.open(file)
    
    filters = transTable[0].tonumpy()
    rms = transTable[1].tonumpy()
    zp = transTable[2].tonumpy()
    zp_err = transTable[3].tonumpy()
    x = transTable[4].tonumpy() # extinction term
    x_err = transTable[5].tonumpy()
    y = transTable[6].tonumpy() # color term
    y_err = transTable[7].tonumpy() 

    data = PhotometryData()
    name = data.name
    if (filter == 'H'):
        m = data.mH
        m_err = data.mH_err
        X = data.XH
        M = data.H
        M_err = data.H_err
        c = data.cHKp
        c_err = data.cHKp_err
        xpos = data.pxH
        ypos = data.pyH

    if (filter == 'Kp'):
        m = data.mKp
        m_err = data.mKp_err
        X = data.XKp
        M = data.Kp
        M_err = data.Kp_err
        c = data.cHKp
        c_err = data.cHKp_err
        xpos = data.pxKp
        ypos = data.pyKp

    if (filter == 'K'):
        m = data.mK
        m_err = data.mK_err
        X = data.XK
        M = data.K
        M_err = data.K_err
        c = data.cHK
        c_err = data.cHK_err
        xpos = data.pxK
        ypos = data.pyK

    # Get rid of nan values
    idx = np.isfinite(m)
    tmp = np.where(idx == True)[0]
    print 'Found %d (out of %d) NaN values.' % (len(m) - len(tmp), len(m))

    name = name[idx]
    m = m[idx]
    m_err = m_err[idx]
    X = X[idx]
    M = M[idx]
    M_err = M_err[idx]
    c = c[idx]
    c_err = c_err[idx]
    xpos = xpos[idx]
    ypos = ypos[idx]

    idx = np.where(filters == filter)[0][0]
    p = np.array([zp[idx], x[idx], y[idx]])

    # Get residuals
    res, res_err = func_residuals(p, m, m_err, X, M, M_err, c, c_err)

    # Get the predicted instrumental magnitude
    m_pred, m_pre_err = func_calc_mag_obs_predicted(p, 
                                                    M, M_err, 
                                                    X, c, c_err)
    # Print out some statistics
    print 'Total |Residuals|     = ', abs(res).sum()
    print 'Average |Residuals|   = ', abs(res).mean()
    print 'Stand. Dev. Residuals = ', res.std()


    # Now we can plot stuff
    magFormatter = py.FormatStrFormatter('%.2f')
    magLocator = py.MultipleLocator(0.02)
    
    ##########
    # Plot Instrumental Magnitude vs. Airmass with Residuals
    ##########
    py.figure(2, figsize=(8,6))
    py.clf()
    py.subplots_adjust(left=0.15, right=0.88)
    py.grid(True)
    py.scatter(X, m, c=res, s=30)
    py.plot(X, m_pred, 'k*', ms=10)
    cbar = py.colorbar(orientation='vertical', pad=0.01, fraction=0.05)
    cbar.ax.get_yaxis().get_label().set_text('Residuals')
    py.legend(('Predicted', 'Observed'), scatterpoints=1, loc='lower right')
    py.xlabel('Airmass')
    py.ylabel('Instrumental Magnitude')
    py.gca().yaxis.set_major_formatter(magFormatter)
    py.title('All Stars, %s-band' % (filter))
    py.savefig('plots/fitp_X_vs_m_all_%s_%s.png' % (filter, suffix))

    ##########
    # Plot Instrumental Magnitude vs. Airmass with Order
    ##########
    order = np.arange(len(m))

    py.figure(2, figsize=(8,6))
    py.clf()
    py.subplots_adjust(left=0.15, right=0.88)
    py.grid(True)
    py.scatter(X, m, c=order, s=30)
    py.plot(X, m_pred, 'k*', ms=10)
    cbar = py.colorbar(orientation='vertical', pad=0.01, fraction=0.05)
    cbar.ax.get_yaxis().get_label().set_text('Order')
    py.legend(('Predicted', 'Observed'), loc='lower right')
    py.xlabel('Airmass')
    py.ylabel('Instrumental Magnitude')
    py.gca().yaxis.set_major_formatter(magFormatter)
    py.title('All Stars, %s-band' % (filter))
    py.savefig('plots/fitp_X_vs_m_order_all_%s_%s.png' % (filter, suffix))

    ##########
    # Plot Instrumental Magnitude vs. Order with 
    # Airmass information (colors) and
    # Position information (symbol sizes).
    ##########
    iiTopLeft = np.where((xpos < 400) & (ypos > 600))[0]
    iiTopRight = np.where((xpos > 600) & (ypos > 600))[0]
    iiBotRight = np.where((xpos > 600) & (ypos < 400))[0]
    iiCenter = np.where((xpos > 400) & (xpos < 600) & 
                        (ypos > 400) & (ypos < 600))[0]

    order = np.arange(len(m))

    py.figure(2, figsize=(8,6))
    py.clf()
    py.subplots_adjust(left=0.15, right=0.88)
    s1 = py.scatter(order[iiCenter], m[iiCenter], c=X[iiCenter], 
                    marker='>',
                    s=100, vmin=X.min(), vmax=X.max())
    s2 = py.scatter(order[iiTopLeft], m[iiTopLeft], c=X[iiTopLeft], 
                    marker='o',
                    s=100, vmin=X.min(), vmax=X.max())
    s3 = py.scatter(order[iiTopRight], m[iiTopRight], c=X[iiTopRight], 
                    marker='s',
                    s=100, vmin=X.min(), vmax=X.max())
    s4 = py.scatter(order[iiBotRight], m[iiBotRight], c=X[iiBotRight], 
                    marker='d',
                    s=100, vmin=X.min(), vmax=X.max())
    # Legend is backwards for some reason
    py.legend((s1, s2, s3, s4), 
              ('Center', 'Top Left', 'Top Right', 'Bottom Right'), 
              scatterpoints=1, loc='lower right')

    py.grid(True)
    py.xlabel('Order')
    py.ylabel('Instrumental Magnitude')
    py.gca().yaxis.set_major_formatter(magFormatter)
    py.gca().yaxis.set_major_locator(magLocator)
    cbar = py.colorbar(orientation='vertical', pad=0.01, fraction=0.05)
    cbar.ax.get_yaxis().get_label().set_text('Airmass')
    py.title('All Stars, %s-band' % (filter))
    py.savefig('plots/fitp_order_vs_m_X_pos_all_%s_%s.png' % (filter, suffix))


    ##########
    # Plot Airmass vs. Residuals with Instrumental Magnitude (color)
    ##########
    # Give different stars, different symbols
    fs140 = np.where(name == 'FS140')[0]
    fs144 = np.where(name == 'FS144')[0]
    fs148 = np.where(name == 'FS148')[0]

    py.figure(2, figsize=(8,6))
    py.clf()
    py.subplots_adjust(left=0.15, right=0.88)
    s1 = py.scatter(X[fs140], res[fs140], c=m[fs140], s=100, marker='o')
    s2 = py.scatter(X[fs144], res[fs144], c=m[fs144], s=100, marker='^')
    s3 = py.scatter(X[fs148], res[fs148], c=m[fs148], s=100, marker='s')
    py.legend((s1, s2, s3), ('FS140', 'FS144', 'FS148'), scatterpoints=1,
              loc='lower right')
    py.grid(True)
    py.xlabel('Airmass')
    py.ylabel('Residuals (mag)')
    cbar = py.colorbar(orientation='vertical', pad=0.01, fraction=0.05,
                       format='%.3f')
    cbar.ax.get_yaxis().get_label().set_text('Instrumental Magnitude')
    py.title('All Stars, %s-band' % (filter))
    py.savefig('plots/fitp_X_vs_res_m_all_%s_%s.png' % (filter, suffix))

    ##########
    # Plot Residuals vs. Color
    ##########
    # Give different stars, different symbols
    py.figure(2, figsize=(8,6))
    py.clf()
    py.subplots_adjust(left=0.15, right=0.88)
    s1 = py.scatter(c[fs140], res[fs140], c=X[fs140], s=100, marker='o')
    s2 = py.scatter(c[fs144], res[fs144], c=X[fs144], s=100, marker='^')
    s3 = py.scatter(c[fs148], res[fs148], c=X[fs148], s=100, marker='s')
    py.legend((s1, s2, s3), ('FS140', 'FS144', 'FS148'), scatterpoints=1,
              loc='lower right')
    py.grid(True)
    py.xlabel('Color')
    py.ylabel('Residuals (mag)')
    cbar = py.colorbar(orientation='vertical', pad=0.01, fraction=0.05,
                       format='%.3f')
    cbar.ax.get_yaxis().get_label().set_text('Airmass')
    py.title('All Stars, %s-band' % (filter))
    py.savefig('plots/fitp_C_vs_res_X_all_%s_%s.png' % (filter, suffix))

    ##########
    # Plot Residuals vs. Color
    ##########
    # Give different stars, different symbols
    py.figure(2, figsize=(8,6))
    py.clf()
    py.subplots_adjust(left=0.15, right=0.88)
    dm = M - m - p[0]
    s1 = py.scatter(X[fs140], dm[fs140], c=m[fs140], s=100, marker='o')
    s2 = py.scatter(X[fs144], dm[fs144], c=m[fs144], s=100, marker='^')
    s3 = py.scatter(X[fs148], dm[fs148], c=m[fs148], s=100, marker='s')
    py.legend((s1, s2, s3), ('FS140', 'FS144', 'FS148'), scatterpoints=1,
              loc='lower right')
    py.grid(True)
    py.xlabel('Airmass')
    py.ylabel('M - m - ZP (mag)')
    cbar = py.colorbar(orientation='vertical', pad=0.01, fraction=0.05,
                       format='%.3f')
    cbar.ax.get_yaxis().get_label().set_text('Instrumental Magnitude')
    py.title('All Stars, %s-band' % (filter))
    py.savefig('plots/fitp_X_vs_magdiff_m_all_%s_%s.png' % (filter, suffix))
    
    
    
def test_fit_trans():
    data = PhotometryData(onlyStar='FS140')

    p, p_err, res, mH_pred = run_fit(data.mH, data.mH_err, data.XH, 
                                    data.H, data.H_err, 
                                    data.cHKp, data.cHKp_err)


    magFormatter = py.FormatStrFormatter('%.2f')
    magLocator = py.MultipleLocator(0.02)

    py.figure(2, figsize=(8,6))
    py.clf()
    py.subplots_adjust(left=0.15, right=0.88)
    py.grid(True)
    py.scatter(data.XH, data.mH, c=res, s=30)
    py.plot(data.XH, mH_pred, 'k*', ms=10)
    cbar = py.colorbar(orientation='vertical', pad=0.01, fraction=0.05)
    cbar.ax.get_yaxis().get_label().set_text('Residuals')
    py.legend(('Predicted', 'Observed'))
    py.xlabel('Airmass')
    py.ylabel('Instrumental Magnitude')
    py.gca().yaxis.set_major_formatter(magFormatter)
    py.title('FS140')
    py.savefig('plots/test_fit_airmass_vs_mH.png')
#     py.show()

    py.figure(2, figsize=(8,6))
    py.clf()
    py.subplots_adjust(left=0.15, right=0.88)
    py.grid(True)
    py.scatter(data.mH, res, c=data.XH, s=data.tH*10.0)
    py.xlabel('Instrumental Magnitude')
    py.ylabel('Residuals')
    py.gca().xaxis.set_major_formatter(magFormatter)
    py.gca().xaxis.set_major_locator(magLocator)
    cbar = py.colorbar(orientation='vertical', pad=0.01, fraction=0.05)
    cbar.ax.get_yaxis().get_label().set_text('Airmass')
    py.title('FS140')
    py.savefig('plots/test_fit_mH_vs_residuals_airmass.png')
#     py.show()

    py.figure(2, figsize=(8,6))
    py.clf()
    py.subplots_adjust(left=0.15, right=0.88)
    py.scatter(data.XH, res, c=data.mH, s=100)
    py.grid(True)
    py.xlabel('Airmass')
    py.ylabel('Residuals (mag)')
    cbar = py.colorbar(orientation='vertical', pad=0.01, fraction=0.05,
                       format='%.3f')
    cbar.ax.get_yaxis().get_label().set_text('Instrumental Magnitude')
    py.title('FS140')
    py.savefig('plots/test_fit_airmass_vs_residuals_mH.png')
#     py.show()

    py.figure(2, figsize=(8,6))
    py.clf()
    py.subplots_adjust(left=0.15, right=0.88)
    symSize = (data.XH - data.XH.min()) / (data.XH.max() - data.XH.min())
    symSize = symSize * 100.0 + 20.0
    py.scatter(data.pxH, data.pyH, c=res, s=symSize)
    py.grid(True)
    py.xlabel('X Position')
    py.ylabel('Y Position')
    cbar = py.colorbar(orientation='vertical', pad=0.01, fraction=0.05,
                       format='%.3f')
    cbar.ax.get_yaxis().get_label().set_text('Residuals')
    py.title('FS140 - Size ~ Airmass')
    py.savefig('plots/test_position_mH.png')
#     py.show()


    iiTopLeft = np.where((data.pxH < 400) & (data.pyH > 600))[0]
    iiTopRight = np.where((data.pxH > 600) & (data.pyH > 600))[0]
    iiBotRight = np.where((data.pxH > 600) & (data.pyH < 400))[0]
    iiCenter = np.where((data.pxH > 400) & (data.pxH < 600) & 
                        (data.pyH > 400) & (data.pyH < 600))[0]

    order = np.arange(len(data.mH))

    py.figure(2, figsize=(8,6))
    py.clf()
    py.subplots_adjust(left=0.15, right=0.88)
    s1 = py.scatter(order[iiCenter], data.mH[iiCenter], c=data.XH[iiCenter], 
                    marker='>',
                    s=100, vmin=data.XH.min(), vmax=data.XH.max())
    s2 = py.scatter(order[iiTopLeft], data.mH[iiTopLeft], c=data.XH[iiTopLeft], 
                    marker='o',
                    s=100, vmin=data.XH.min(), vmax=data.XH.max())
    s3 = py.scatter(order[iiTopRight], data.mH[iiTopRight], c=data.XH[iiTopRight], 
                    marker='s',
                    s=100, vmin=data.XH.min(), vmax=data.XH.max())
    s4 = py.scatter(order[iiBotRight], data.mH[iiBotRight], c=data.XH[iiBotRight], 
                    marker='d',
                    s=100, vmin=data.XH.min(), vmax=data.XH.max())
    # Legend is backwards for some reason
    py.legend((s1, s2, s3, s4), 
              ('Center', 'Top Left', 'Top Right', 'Bottom Right'), 
              scatterpoints=1)

    py.grid(True)
    py.xlabel('Order')
    py.ylabel('Instrumental Magnitude')
    py.gca().yaxis.set_major_formatter(magFormatter)
    py.gca().yaxis.set_major_locator(magLocator)
    cbar = py.colorbar(orientation='vertical', pad=0.01, fraction=0.05)
    cbar.ax.get_yaxis().get_label().set_text('Airmass')
    py.title('FS140')
    py.savefig('plots/test_fit_order_vs_mH_airmass.png')
    py.show()

    
    
def fit_trans_all():
    for ss in stars:
        print '\n *** %s  H-band: ' % ss
        fit_trans(ss, 'H')

        print '\n *** %s  Kp-band: ' % ss
        fit_trans(ss, 'Kp')

        print '\n *** %s  K-band: ' % ss
        fit_trans(ss, 'K')

def fit_trans(star, filter):
    # First lets fit each star in each filter seperately.
    data = PhotometryData(onlyStar=star)

    if (filter == 'H'):
        m = data.mH
        m_err = data.mH_err
        X = data.XH
        M = data.H
        M_err = data.H_err
        c = data.cHKp
        c_err = data.cHKp_err
        xpos = data.pxH
        ypos = data.pyH

    if (filter == 'Kp'):
        m = data.mKp
        m_err = data.mKp_err
        X = data.XKp
        M = data.Kp
        M_err = data.Kp_err
        c = data.cHKp
        c_err = data.cHKp_err
        xpos = data.pxKp
        ypos = data.pyKp

    if (filter == 'K'):
        m = data.mK
        m_err = data.mK_err
        X = data.XK
        M = data.K
        M_err = data.K_err
        c = data.cHK
        c_err = data.cHK_err
        xpos = data.pxK
        ypos = data.pyK

    # Get rid of nan values
    idx = np.isfinite(m)
    tmp = np.where(idx == True)[0]
    print 'Found %d (out of %d) NaN values.' % (len(m) - len(tmp), len(m))

    m = m[idx]
    m_err = m_err[idx]
    X = X[idx]
    M = M[idx]
    M_err = M_err[idx]
    c = c[idx]
    c_err = c_err[idx]
    xpos = xpos[idx]
    ypos = ypos[idx]

    p, p_err, res, m_pred = run_fit(m, m_err, X, M, M_err, c, c_err)

    magFormatter = py.FormatStrFormatter('%.2f')
    magLocator = py.MultipleLocator(0.02)
    
    ##########
    # Plot Instrumental Magnitude vs. Airmass with Residuals
    ##########
    py.figure(2, figsize=(8,6))
    py.clf()
    py.subplots_adjust(left=0.15, right=0.88)
    py.grid(True)
    py.scatter(X, m, c=res, s=30)
    py.plot(X, m_pred, 'k*', ms=10)
    cbar = py.colorbar(orientation='vertical', pad=0.01, fraction=0.05)
    cbar.ax.get_yaxis().get_label().set_text('Residuals')
    py.legend(('Predicted', 'Observed'), scatterpoints=1)
    py.xlabel('Airmass')
    py.ylabel('Instrumental Magnitude')
    py.gca().yaxis.set_major_formatter(magFormatter)
    py.title('%s %s-band' % (star, filter))
    py.savefig('plots/fit_airmass_vs_m_%s_%s.png' % (star, filter))

    ##########
    # Plot Instrumental Magnitude vs. Airmass with Order
    ##########
    order = np.arange(len(m))

    py.figure(2, figsize=(8,6))
    py.clf()
    py.subplots_adjust(left=0.15, right=0.88)
    py.grid(True)
    py.scatter(X, m, c=order, s=30)
    py.plot(X, m_pred, 'k*', ms=10)
    cbar = py.colorbar(orientation='vertical', pad=0.01, fraction=0.05)
    cbar.ax.get_yaxis().get_label().set_text('Order')
    py.legend(('Predicted', 'Observed'))
    py.xlabel('Airmass')
    py.ylabel('Instrumental Magnitude')
    py.gca().yaxis.set_major_formatter(magFormatter)
    py.title('%s %s-band' % (star, filter))
    py.savefig('plots/fit_airmass_vs_m_order_%s_%s.png' % (star, filter))

    ##########
    # Plot Instrumental Magnitude vs. Order with 
    # Airmass information (colors) and
    # Position information (symbol sizes).
    ##########
    iiTopLeft = np.where((xpos < 400) & (ypos > 600))[0]
    iiTopRight = np.where((xpos > 600) & (ypos > 600))[0]
    iiBotRight = np.where((xpos > 600) & (ypos < 400))[0]
    iiCenter = np.where((xpos > 400) & (xpos < 600) & 
                        (ypos > 400) & (ypos < 600))[0]

    order = np.arange(len(m))

    py.figure(2, figsize=(8,6))
    py.clf()
    py.subplots_adjust(left=0.15, right=0.88)
    s1 = py.scatter(order[iiCenter], m[iiCenter], c=X[iiCenter], 
                    marker='>',
                    s=100, vmin=X.min(), vmax=X.max())
    s2 = py.scatter(order[iiTopLeft], m[iiTopLeft], c=X[iiTopLeft], 
                    marker='o',
                    s=100, vmin=X.min(), vmax=X.max())
    s3 = py.scatter(order[iiTopRight], m[iiTopRight], c=X[iiTopRight], 
                    marker='s',
                    s=100, vmin=X.min(), vmax=X.max())
    s4 = py.scatter(order[iiBotRight], m[iiBotRight], c=X[iiBotRight], 
                    marker='d',
                    s=100, vmin=X.min(), vmax=X.max())
    # Legend is backwards for some reason
    py.legend((s1, s2, s3, s4), 
              ('Center', 'Top Left', 'Top Right', 'Bottom Right'), 
              scatterpoints=1)

    py.grid(True)
    py.xlabel('Order')
    py.ylabel('Instrumental Magnitude')
    py.gca().yaxis.set_major_formatter(magFormatter)
    py.gca().yaxis.set_major_locator(magLocator)
    cbar = py.colorbar(orientation='vertical', pad=0.01, fraction=0.05)
    cbar.ax.get_yaxis().get_label().set_text('Airmass')
    py.title('%s, %s-band' % (star, filter))
    py.savefig('plots/fit_order_vs_m_airmass_position_%s_%s.png' % 
               (star, filter))


    ##########
    # Plot Airmass vs. Residuals with Instrumental Magnitude (color)
    ##########
    py.figure(2, figsize=(8,6))
    py.clf()
    py.subplots_adjust(left=0.15, right=0.88)
    py.scatter(X, res, c=m, s=100)
    py.grid(True)
    py.xlabel('Airmass')
    py.ylabel('Residuals (mag)')
    cbar = py.colorbar(orientation='vertical', pad=0.01, fraction=0.05,
                       format='%.3f')
    cbar.ax.get_yaxis().get_label().set_text('Instrumental Magnitude')
    py.title('%s, %s-band' % (star, filter))
    py.savefig('plots/fit_airmass_vs_residuals_m_%s_%s.png' % (star, filter))


    ##########
    # Plot Residuals vs. Color
    ##########
    # Give different stars, different symbols
    py.figure(2, figsize=(8,6))
    py.clf()
    py.subplots_adjust(left=0.15, right=0.88)
    py.scatter(c, res, c=X, s=100, marker='o')
    py.grid(True)
    py.xlabel('Color')
    py.ylabel('Residuals (mag)')
    cbar = py.colorbar(orientation='vertical', pad=0.01, fraction=0.05,
                       format='%.3f')
    cbar.ax.get_yaxis().get_label().set_text('Airmass')
    py.title('%s, %s-band' % (star, filter))
    py.savefig('plots/fit_color_vs_residuals_airmass_%s_%s.png' % (star, filter))

    ##########
    # Plot Residuals vs. Color
    ##########
    # Give different stars, different symbols
    py.figure(2, figsize=(8,6))
    py.clf()
    py.subplots_adjust(left=0.15, right=0.88)
    dm = M - m - p[0]
    py.scatter(X, dm, c=m, s=100, marker='o')
    py.grid(True)
    py.xlabel('Airmass')
    py.ylabel('M - m - ZP (mag)')
    cbar = py.colorbar(orientation='vertical', pad=0.01, fraction=0.05,
                       format='%.3f')
    cbar.ax.get_yaxis().get_label().set_text('Instrumental Magnitude')
    py.title('%s, %s-band' % (star, filter))
    py.savefig('plots/fit_airmass_vs_magdiff_m_%s_%s.png' % (star, filter))


    return p

def fit_trans_combined(filter):
    # First lets fit each star in each filter seperately.
    data = PhotometryData()

    if (filter == 'H'):
        m = data.mH
        m_err = data.mH_err
        X = data.XH
        M = data.H
        M_err = data.H_err
        c = data.cHKp
        c_err = data.cHKp_err
        xpos = data.pxH
        ypos = data.pyH

    if (filter == 'Kp'):
        m = data.mKp
        m_err = data.mKp_err
        X = data.XKp
        M = data.Kp
        M_err = data.Kp_err
        c = data.cHKp
        c_err = data.cHKp_err
        xpos = data.pxKp
        ypos = data.pyKp

    if (filter == 'K'):
        m = data.mK
        m_err = data.mK_err
        X = data.XK
        M = data.K
        M_err = data.K_err
        c = data.cHK
        c_err = data.cHK_err
        xpos = data.pxK
        ypos = data.pyK

    # Get rid of nan values
    idx = np.isfinite(m)
    tmp = np.where(idx == True)[0]
    print 'Found %d (out of %d) NaN values.' % (len(m) - len(tmp), len(m))

    name = data.name[idx]
    m = m[idx]
    m_err = m_err[idx]
    X = X[idx]
    M = M[idx]
    M_err = M_err[idx]
    c = c[idx]
    c_err = c_err[idx]
    xpos = xpos[idx]
    ypos = ypos[idx]

    p, p_err, res, m_pred = run_fit(m, m_err, X, M, M_err, c, c_err)

    magFormatter = py.FormatStrFormatter('%.2f')
    magLocator = py.MultipleLocator(0.02)
    
    ##########
    # Plot Instrumental Magnitude vs. Airmass with Residuals
    ##########
    py.figure(2, figsize=(8,6))
    py.clf()
    py.subplots_adjust(left=0.15, right=0.88)
    py.grid(True)
    py.scatter(X, m, c=res, s=30)
    py.plot(X, m_pred, 'k*', ms=10)
    cbar = py.colorbar(orientation='vertical', pad=0.01, fraction=0.05)
    cbar.ax.get_yaxis().get_label().set_text('Residuals')
    py.legend(('Predicted', 'Observed'), scatterpoints=1, loc='lower right')
    py.xlabel('Airmass')
    py.ylabel('Instrumental Magnitude')
    py.gca().yaxis.set_major_formatter(magFormatter)
    py.title('All Stars, %s-band' % (filter))
    py.savefig('plots/fit_airmass_vs_m_all_%s.png' % (filter))

    ##########
    # Plot Instrumental Magnitude vs. Airmass with Order
    ##########
    order = np.arange(len(m))

    py.figure(2, figsize=(8,6))
    py.clf()
    py.subplots_adjust(left=0.15, right=0.88)
    py.grid(True)
    py.scatter(X, m, c=order, s=30)
    py.plot(X, m_pred, 'k*', ms=10)
    cbar = py.colorbar(orientation='vertical', pad=0.01, fraction=0.05)
    cbar.ax.get_yaxis().get_label().set_text('Order')
    py.legend(('Predicted', 'Observed'), loc='lower right')
    py.xlabel('Airmass')
    py.ylabel('Instrumental Magnitude')
    py.gca().yaxis.set_major_formatter(magFormatter)
    py.title('All Stars, %s-band' % (filter))
    py.savefig('plots/fit_airmass_vs_m_order_all_%s.png' % (filter))

    ##########
    # Plot Instrumental Magnitude vs. Order with 
    # Airmass information (colors) and
    # Position information (symbol sizes).
    ##########
    iiTopLeft = np.where((xpos < 400) & (ypos > 600))[0]
    iiTopRight = np.where((xpos > 600) & (ypos > 600))[0]
    iiBotRight = np.where((xpos > 600) & (ypos < 400))[0]
    iiCenter = np.where((xpos > 400) & (xpos < 600) & 
                        (ypos > 400) & (ypos < 600))[0]

    order = np.arange(len(m))

    py.figure(2, figsize=(8,6))
    py.clf()
    py.subplots_adjust(left=0.15, right=0.88)
    s1 = py.scatter(order[iiCenter], m[iiCenter], c=X[iiCenter], 
                    marker='>',
                    s=100, vmin=X.min(), vmax=X.max())
    s2 = py.scatter(order[iiTopLeft], m[iiTopLeft], c=X[iiTopLeft], 
                    marker='o',
                    s=100, vmin=X.min(), vmax=X.max())
    s3 = py.scatter(order[iiTopRight], m[iiTopRight], c=X[iiTopRight], 
                    marker='s',
                    s=100, vmin=X.min(), vmax=X.max())
    s4 = py.scatter(order[iiBotRight], m[iiBotRight], c=X[iiBotRight], 
                    marker='d',
                    s=100, vmin=X.min(), vmax=X.max())
    # Legend is backwards for some reason
    py.legend((s1, s2, s3, s4), 
              ('Center', 'Top Left', 'Top Right', 'Bottom Right'), 
              scatterpoints=1, loc='lower right')

    py.grid(True)
    py.xlabel('Order')
    py.ylabel('Instrumental Magnitude')
    py.gca().yaxis.set_major_formatter(magFormatter)
    py.gca().yaxis.set_major_locator(magLocator)
    cbar = py.colorbar(orientation='vertical', pad=0.01, fraction=0.05)
    cbar.ax.get_yaxis().get_label().set_text('Airmass')
    py.title('All Stars, %s-band' % (filter))
    py.savefig('plots/fit_order_vs_m_airmass_position_all_%s.png' % (filter))


    ##########
    # Plot Airmass vs. Residuals with Instrumental Magnitude (color)
    ##########
    # Give different stars, different symbols
    fs140 = np.where(name == 'FS140')[0]
    fs144 = np.where(name == 'FS144')[0]
    fs148 = np.where(name == 'FS148')[0]

    py.figure(2, figsize=(8,6))
    py.clf()
    py.subplots_adjust(left=0.15, right=0.88)
    s1 = py.scatter(X[fs140], res[fs140], c=m[fs140], s=100, marker='o')
    s2 = py.scatter(X[fs144], res[fs144], c=m[fs144], s=100, marker='^')
    s3 = py.scatter(X[fs148], res[fs148], c=m[fs148], s=100, marker='s')
    py.legend((s1, s2, s3), ('FS140', 'FS144', 'FS148'), scatterpoints=1,
              loc='lower right')
    py.grid(True)
    py.xlabel('Airmass')
    py.ylabel('Residuals (mag)')
    cbar = py.colorbar(orientation='vertical', pad=0.01, fraction=0.05,
                       format='%.3f')
    cbar.ax.get_yaxis().get_label().set_text('Instrumental Magnitude')
    py.title('All Stars, %s-band' % (filter))
    py.savefig('plots/fit_airmass_vs_residuals_m_all_%s.png' % (filter))

    ##########
    # Plot Residuals vs. Color
    ##########
    # Give different stars, different symbols
    py.figure(2, figsize=(8,6))
    py.clf()
    py.subplots_adjust(left=0.15, right=0.88)
    s1 = py.scatter(c[fs140], res[fs140], c=X[fs140], s=100, marker='o')
    s2 = py.scatter(c[fs144], res[fs144], c=X[fs144], s=100, marker='^')
    s3 = py.scatter(c[fs148], res[fs148], c=X[fs148], s=100, marker='s')
    py.legend((s1, s2, s3), ('FS140', 'FS144', 'FS148'), scatterpoints=1,
              loc='lower right')
    py.grid(True)
    py.xlabel('Color')
    py.ylabel('Residuals (mag)')
    cbar = py.colorbar(orientation='vertical', pad=0.01, fraction=0.05,
                       format='%.3f')
    cbar.ax.get_yaxis().get_label().set_text('Airmass')
    py.title('All Stars, %s-band' % (filter))
    py.savefig('plots/fit_color_vs_residuals_airmass_all_%s.png' % (filter))

    ##########
    # Plot Residuals vs. Color
    ##########
    # Give different stars, different symbols
    py.figure(2, figsize=(8,6))
    py.clf()
    py.subplots_adjust(left=0.15, right=0.88)
    dm = M - m - p[0]
    s1 = py.scatter(X[fs140], dm[fs140], c=m[fs140], s=100, marker='o')
    s2 = py.scatter(X[fs144], dm[fs144], c=m[fs144], s=100, marker='^')
    s3 = py.scatter(X[fs148], dm[fs148], c=m[fs148], s=100, marker='s')
    py.legend((s1, s2, s3), ('FS140', 'FS144', 'FS148'), scatterpoints=1,
              loc='lower right')
    py.grid(True)
    py.xlabel('Airmass')
    py.ylabel('M - m - ZP (mag)')
    cbar = py.colorbar(orientation='vertical', pad=0.01, fraction=0.05,
                       format='%.3f')
    cbar.ax.get_yaxis().get_label().set_text('Instrumental Magnitude')
    py.title('All Stars, %s-band' % (filter))
    py.savefig('plots/fit_airmass_vs_magdiff_m_all_%s.png' % (filter))


    return p

def run_fit(m, m_err, AM, M, M_err, c, c_err):
    p0 = [25.0, -0.05]

    ##########
    # MPFIT
    ##########
    print '\n\n'
    print '##########'
    print '# MPFIT'
    print '##########'
    from pytools.nmpfit import mpfit
    import copy
    nparams = len(p0)
    infoTemplate = {'parname':'', 'value':0, 'step':0.0, 'fixed':0, 
                       'limits':[0., 0.], 'limited':[0, 0]}
    parinfo = []
    for ii in range(nparams):
        parinfo.append(copy.deepcopy(infoTemplate))
    
    # Zeropoint
    parinfo[0]['parname'] = 'Zeropoint'
    parinfo[0]['value'] = p0[0]
    parinfo[0]['limited'] = [1, 1]
    parinfo[0]['limits'] = [20.0, 30.0]
    
    # Airmass Coefficient
    parinfo[1]['parname'] = 'Airmass Coefficient'
    parinfo[1]['value'] = p0[1]
    parinfo[1]['step'] = 0.001
    parinfo[1]['limited'] = [1, 1]
    parinfo[1]['limits'] = [-1, 1]

    # Color Term
    if nparams > 2:
        parinfo[2]['parname'] = 'Color Term'
        parinfo[2]['value'] = p0[2]
        parinfo[2]['limited'] = [1, 1]
        parinfo[2]['limits'] = [-0.1, 0.1]
        parinfo[2]['step'] = 0.001

    # Color-Airmass Term
    if nparams > 3:
        parinfo[3]['parname'] = 'Airmass/Color Term'
        parinfo[3]['value'] = p0[3]
        parinfo[3]['limited'] = [1, 1]
        parinfo[3]['limits'] = [-0.1, 0.1]


    args = {'m': m, 'merr': m_err, 'AM': AM, 'M': M, 'Merr': M_err, 
            'C': c, 'Cerr': c_err}

    output = mpfit(mpfit_func_fit, p0, functkw=args, parinfo=parinfo,
                   xtol=1e-15, gtol=1e-16, ftol=1e-16)
    print 'Fit Status:'
    print '  %d %s' % (output.status, output.errmsg)
    print
    print "Fitted parameters at minimum:" 
    for ii in range(len(output.params)):
        print "%2d  %-20s  %12f +/- %10f" % \
            (ii, parinfo[ii]['parname'], output.params[ii], output.perror[ii]) 
    print
        
    p = output.params
    p_err = output.perror

#     ##########
#     # SCIPY.OPTIMIZE.LEASTSQ
#     ##########
#     print '\n\n'
#     print '##########'
#     print '# SCIPY.OPTIMIZE.LEASTSQ'
#     print '##########'
#     weights = 1.0 / np.sqrt(m_err**2 + M_err**2)
#     output = optimize.leastsq(func_fit, p0, full_output=1,
#                               args=(m, m_err, AM, 
#                                     M, M_err, c, c_err))#,
# #                              diag=weights)

#     p = output[0]
#     cov = output[1]
#     info = output[2]
#     mesg = output[3]
#     success = output[4]

#     chisq = np.sum(info["fvec"]*info["fvec"])
#     dof = len(m) - len(p)

#     print 'Converged with chi squared ', chisq
#     print 'degrees of freedom, dof ', dof
#     print 'RMS of residuals (i.e. sqrt(chisq/dof))', math.sqrt(chisq/dof)
#     print 'Reduced chisq (i.e. variance of residuals)', chisq/dof
#     print ''

#     # Uncertainties in parameters
#     # uncertainties are calculated as per gnuplot, "fixing" the result 
#     # for non unit values of the reduced chisq. 
#     # values at min match gnuplot 
#     print "Fitted parameters at minimum, with 68% C.I.:" 
#     for i, pmin in enumerate(p): 
#         print "%2d %12f +/- %10f" % \
#             (i, pmin, math.sqrt(cov[i,i]**2)) 
#     print 

#     print "Correlation matrix" 
#     # correlation matrix close to gnuplot 
#     print "               ", 
#     for i in range(len(p)): print "p[%d]      " % (i), 
#     print 
#     for i in range(len(p)): 
#         print "   p[%d]   " % i, 
#         for j in range(i+1): 
#             print "%10f" % (cov[i,j]/math.sqrt(cov[i,i]*cov[j,j]),), 
#         print 

#     print 'Results: ', success, mesg
#     print '           Zeropoint = %7.3f' % p[0]
#     print ' Airmass Coefficient = %9.5f' % p[1]
# #     print '          Color Term = %9.5f' % p[2]
# #     print '  Airmass Color Term = %9.5f' % p[3]



    # Get residuals
    res, res_err = func_residuals(p, m, m_err, AM, M, M_err, c, c_err)

    # Get the predicted instrumental magnitude
    m_pred, m_pre_err = func_calc_mag_obs_predicted(p, 
                                                    M, M_err, 
                                                    AM, c, c_err)

    return p, p_err, res, m_pred


### Functions for fit_transformations() ###
def func_calc_mag_absolute(params, m, merr, AM, C, Cerr):
    """
    absolute mag = instrumental mag + zeropoint + k * airmass
    """
    zeropoint = params[0]
    airmassTerm = params[1]
    
    mag = m + zeropoint + (airmassTerm * AM)
    magErr2 = merr**2
    
    # Color term
    if len(params) > 2:
        colorTerm = params[2]

        mag += colorTerm * C
#         magErr2 += Cerr**2 * colorTerm**2
        
    # Color Airmass Term
    if len(params) > 3:
        amColorTerm = params[3]

        mag += amColorTerm * C * AM
#         magErr2 += Cerr**2 * AM**2 * amColorTerm**2

    # Calc Errors
    magErr = np.sqrt(magErr2)
    
    return (mag, magErr)

def func_calc_mag_obs_predicted(params, M, Merr, AM, C, Cerr):
    """
    predicted instrumental mag = absolute mag - zeropoint - k * airmass
    """
    zeropoint = params[0]
    airmassTerm = params[1]

    mag = M - zeropoint - (airmassTerm * AM)
    magErr2 = Merr**2

    # Color term
    if len(params) > 2:
        colorTerm = params[2]

        mag -= colorTerm * C
#         magErr2 += Cerr**2 * colorTerm**2
        
    # Color Airmass Term
    if len(params) > 3:
        amColorTerm = params[3]

        mag -= amColorTerm * C * AM
#         magErr2 += Cerr**2 * AM**2 * amColorTerm**2

    # Calc Errors
    magErr = np.sqrt(magErr2)

    return (mag, magErr)


def func_residuals(params, m, merr, AM, M, Merr, C, Cerr):
    # m = observed instrumental magnitude
    # AM = observed airmass
    # M = standard magnitude above the atmosphere
    # C = standard color above the atmosphere
    M_predicted, Merr_predicted = func_calc_mag_absolute(params, 
                                                         m, merr, AM, C, Cerr)
    
    diff = M - M_predicted
    diff_err = np.sqrt(Merr**2 + Merr_predicted**2)
    
    return (diff, diff_err)

def func_fit(params, m, merr, AM, M, Merr, C, Cerr):
    diff, diff_err = func_residuals(params, m, merr, AM, M, Merr, C, Cerr)
    
    return diff / diff_err

def mpfit_func_fit(params, fjac=None, 
                   m=None, merr=None, AM=None, M=None, Merr=None, 
                   C=None, Cerr=None):
    diff, diff_err = func_residuals(params, m, merr, AM, M, Merr, C, Cerr)
    
    return (0, diff / diff_err)
#     return (0, diff / merr)


### Load Up Photometry Data ###
class PhotometryData():
    def __init__(self, onlyStar=None):
        # Change INDEF to nan
        old = open('standards.instMag', 'r')
        new = open('standards.instMag2', 'w')
        
        lines = old.readlines()
        for line in lines:
            newline = line.replace('INDEF', '  nan')
            new.write(newline)
        old.close()
        new.close()

        # Read in data
        obsdata = asciidata.open('standards.instMag2')
        
        name = np.array([oo.strip() for oo in obsdata[0]._data])

        mH = obsdata[6].tonumpy()
        mH_err = obsdata[7].tonumpy()
        XH = obsdata[3].tonumpy()
        pxH = obsdata[4].tonumpy()
        pyH = obsdata[5].tonumpy()
        tH_str = obsdata[2].tonumpy()
        tH = np.zeros(len(tH_str), dtype=float)
        for ii in range(len(tH_str)):
            if tH_str[ii] != 'nan':
                tH_parts = tH_str[ii].split(':')
                tH[ii] = float(tH_parts[0]) + \
                    float(tH_parts[1])/60.0 + \
                    float(tH_parts[2])/3600.0
            else:
                tH[ii] = np.nan
        
        mKp = obsdata[13].tonumpy()
        mKp_err = obsdata[14].tonumpy()
        XKp = obsdata[10].tonumpy()
        pxKp = obsdata[11].tonumpy()
        pyKp = obsdata[12].tonumpy()
        tKp_str = obsdata[2].tonumpy()
        tKp = np.zeros(len(tKp_str), dtype=float)
        for ii in range(len(tKp_str)):
            if tKp_str[ii] != 'nan':
                tKp_parts = tKp_str[ii].split(':')
                tKp[ii] = float(tKp_parts[0]) + \
                    float(tKp_parts[1])/60.0 + \
                    float(tKp_parts[2])/3600.0
            else:
                tKp[ii] = np.nan
        
        mK = obsdata[20].tonumpy()
        mK_err = obsdata[21].tonumpy()
        XK = obsdata[17].tonumpy()
        pxK = obsdata[18].tonumpy()
        pyK = obsdata[19].tonumpy()
        tK_str = obsdata[2].tonumpy()
        tK = np.zeros(len(tK_str), dtype=float)
        for ii in range(len(tK_str)):
            if tK_str[ii] != 'nan':
                tK_parts = tK_str[ii].split(':')
                tK[ii] = float(tK_parts[0]) + \
                    float(tK_parts[1])/60.0 + \
                    float(tK_parts[2])/3600.0
            else:
                tK[ii] = np.nan
        
        # Read in catalog of standards
        stddata = asciidata.open('photcal_ukirt_faint.dat')
        stdname = np.array([ss.strip() for ss in stddata[0]._data])
        stdH = stddata[1].tonumpy()
        stdH_err = stddata[2].tonumpy()
        stdKp = stddata[3].tonumpy()
        stdKp_err = stddata[4].tonumpy()
        stdK = stddata[5].tonumpy()
        stdK_err = stddata[6].tonumpy()
        
        ##########
        # Cross-correlate to match
        ##########
        H = np.zeros(len(mH), dtype=float)
        H_err = np.zeros(len(mH), dtype=float)
        Kp = np.zeros(len(mKp), dtype=float)
        Kp_err = np.zeros(len(mKp), dtype=float)
        K = np.zeros(len(mK), dtype=float)
        K_err = np.zeros(len(mK), dtype=float)

        for ii in range(len(mH)):
            idx = np.where(stdname == name[ii])[0]
            H[ii] = stdH[idx]
            H_err[ii] = stdH_err[idx]
            Kp[ii] = stdKp[idx]
            Kp_err[ii] = stdKp_err[idx]
            K[ii] = stdK[idx]
            K_err[ii] = stdK_err[idx]

        # Need colors
            cHKp = H - Kp
            cHKp_err = np.sqrt(H_err**2 + Kp_err**2)
            cHK = H - K
            cHK_err = np.sqrt(H_err**2 + K_err**2)

        if (onlyStar == None):
            self.name = name
            self.mH = mH
            self.mH_err = mH_err
            self.XH = XH
            self.pxH = pxH
            self.pyH = pyH
            self.tH = tH
            self.H = H
            self.H_err = H_err
        
            self.mKp = mKp
            self.mKp_err = mKp_err
            self.XKp = XKp
            self.pxKp = pxKp
            self.pyKp = pyKp
            self.tKp = tKp
            self.Kp = Kp
            self.Kp_err = Kp_err
            
            self.mK = mK
            self.mK_err = mK_err
            self.XK = XK
            self.pxK = pxK
            self.pyK = pyK
            self.tK = tK
            self.K = K
            self.K_err = K_err
            
            self.cHKp = cHKp
            self.cHKp_err = cHKp_err
            self.cHK = cHK
            self.cHK_err = cHK_err

        else:
            idx = np.where(name == onlyStar)[0]

            self.name = name[idx]
            self.mH = mH[idx]
            self.mH_err = mH_err[idx]
            self.XH = XH[idx]
            self.pxH = pxH[idx]
            self.pyH = pyH[idx]
            self.tH = tH[idx]
            self.H = H[idx]
            self.H_err = H_err[idx]
        
            self.mKp = mKp[idx]
            self.mKp_err = mKp_err[idx]
            self.XKp = XKp[idx]
            self.pxKp = pxKp[idx]
            self.pyKp = pyKp[idx]
            self.tKp = tKp[idx]
            self.Kp = Kp[idx]
            self.Kp_err = Kp_err[idx]
            
            self.mK = mK[idx]
            self.mK_err = mK_err[idx]
            self.XK = XK[idx]
            self.pxK = pxK[idx]
            self.pyK = pyK[idx]
            self.tK = tK[idx]
            self.K = K[idx]
            self.K_err = K_err[idx]
            
            self.cHKp = cHKp[idx]
            self.cHKp_err = cHKp_err[idx]
            self.cHK = cHK[idx]
            self.cHK_err = cHK_err[idx]
        

        
